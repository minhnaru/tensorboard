<!--
@license
Copyright 2016 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<link rel="import" href="../iron-collapse/iron-collapse.html">
<link rel="import" href="../iron-list/iron-list.html">
<link rel="import" href="../paper-button/paper-button.html">
<link rel="import" href="../paper-icon-button/paper-icon-button.html">
<link rel="import" href="../paper-item/paper-item-body.html">
<link rel="import" href="../paper-item/paper-item.html">
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../tf-graph-common/tf-graph-common.html">
<link rel="import" href="tf-graph-icon.html">
<link rel="import" href="tf-node-list-item.html">

<dom-module id="tf-edge-info">
  <style>
    .sub-list-group {
      font-weight: 500;
      font-size: 12pt;
      padding-bottom: 8px;
      width: 100%;
    }

    .sub-list {
      max-height: 300px;
      overflow-y: scroll;
    }

    .attr-left {
      float: left;
      width: 30%;
      word-wrap: break-word;
      color: #565656;
      font-size: 11pt;
      font-weight: 400;
    }

    .attr-right {
      margin-left: 30%;
      word-wrap: break-word;
      color: #565656;
      font-weight: 400;
    }

    .sub-list-table {
      display: table;
      width: 100%;
    }

    .sub-list-table-row {
      display: table-row;
    }

    .sub-list-table-row .sub-list-table-cell:last-child {
      text-align: right;
    }

    .sub-list-table-cell {
      color: #565656;
      display: table-cell;
      font-size: 11pt;
      font-weight: 400;
      max-width: 200px;
      padding: 0 4px;
    }

    paper-item {
      padding: 0;
      background: #e9e9e9;
    }

    paper-item-body[two-line] {
      min-height: 0;
      padding: 8px 12px 4px;
    }

    .expandedInfo {
      padding: 8px 12px;
    }

    .controlDeps {
      padding: 0 0 0 8px;
    }

    .edge-name {
      white-space: normal;
      word-wrap: break-word;
      font-size: 14pt;
      font-weight: 500;
    }

    .edge-icon {
      float: right;
    }

    .subtitle {
      font-size: 12pt;
      color: #5e5e5e;
    }

    .controlLine {
      font-size: 11pt;
      font-weight: 400;
    }

    .toggle-button {
      float: right;
      max-height: 20px;
      max-width: 20px;
      padding: 0;
    }

    .control-toggle-button {
      float: left;
      max-height: 20px;
      max-width: 20px;
      padding: 0;
    }

    .toggle-include-group {
      padding-top: 4px;
    }

    .toggle-include {
      margin: 5px 6px;
      text-transform: none;
      padding: 4px 6px;
      font-size: 10pt;
      background-color: #fafafa;
      color: #666;
    }

    .toggle-include:hover {
      background-color: var(--google-yellow-100);
    }

    .non-control-list-item {
      padding-left: 10px;
    }

    .show {
      display: block;
    }

    .hidden {
      display: none;
    }
  </style>
  <template>
    <paper-item>
      <paper-item-body two-line>
        <div>
          <paper-icon-button icon="{{_getToggleIcon(_expanded)}}" on-click="_toggleExpanded" class="toggle-button">
          </paper-icon-button>
          <div class="edge-name" id="edgetitle"></div>
        </div>
        <div secondary>
          <!-- <tf-graph-icon class="edge-icon" edge="[[_edge]]"
              render-info="[[_getRenderInfo(edgeName, renderHierarchy)]]"
              color-by="[[colorBy]]"
              template-index="[[_templateIndex]]"
              ></tf-graph-icon> -->
          <!-- <template is="dom-if" if="{{_edge.op}}">
            <div class="subtitle">
              Operation:
              <span>[[_edge.op]]</span>
            </div>
          </template> -->
          <!-- <template is="dom-if" if="{{_edge.metagraph}}">
            <div class="subtitle">
              Subgraph:
              <span>[[_edge.cardinality]]</span> nodes
            </div>
          </template> -->
        </div>
      </paper-item-body>
    </paper-item>
    <iron-collapse opened="{{_expanded}}">
      <template is="dom-if" if="{{_expanded}}" restamp="true">
        <div class="expandedInfo">
          <div class="sub-list-group predecessors">
            Head
            <iron-list class="sub-list" id="headList" items="[[_predecessors.regular]]">
              <template>
                <!-- <tf-node-list-item
                  class="non-control-list-item"
                  card-node="[[_edge]]"
                  item-node="[[item.node]]"
                  edge-label="[[item.edgeLabel]]"
                  item-render-info="[[item.renderInfo]]"
                  name="[[item.name]]"
                  item-type="predecessors"
                  color-by="[[colorBy]]"
                  template-index="[[_templateIndex]]">
              </tf-node-list-item> -->
              </template>
            </iron-list>
          </div>
          <div class="sub-list-group">
            Tail
            <iron-list class="sub-list" id="tailList" items="[[_predecessors.regular]]">
              <template>
                <!-- <tf-node-list-item
                    class="non-control-list-item"
                    card-node="[[_edge]]"
                    item-node="[[item.node]]"
                    edge-label="[[item.edgeLabel]]"
                    item-render-info="[[item.renderInfo]]"
                    name="[[item.name]]"
                    item-type="predecessors"
                    color-by="[[colorBy]]"
                    template-index="[[_templateIndex]]">
                </tf-node-list-item> -->
              </template>
            </iron-list>
          </div>
        </div>
      </template>
    </iron-collapse>
  </template>

  <script>
    (function () {
      Polymer({
        is: 'tf-edge-info',

        properties: {
          edgeName: String,
          graphHierarchy: Object,
          renderHierarchy: Object,
          /** What to color the nodes by (compute time, memory, device etc.) */
          colorBy: String,
          // _templateIndex: {
          //   type: Function,
          //   computed: '_getTemplateIndex(graphHierarchy)'
          // },
          _edge: {
            type: Object,
            computed: '_getEdge(edgeName, graphHierarchy)',
            observer: '_resetState'
          },
          _expanded: {
            type: Boolean,
            value: true
          },
          // _head: {
          //   type: Object,
          //   computed: '_getHeads(_edge, graphHierarchy)'
          // },
          // _tail: {
          //   type: Object,
          //   computed: '_getTails(_edge, graphHierarchy)'
          // },
          _auxButtonText: String,
          _groupButtonText: String
        },
        listeners: {
          'edge-info-select': '_edgeInfoSelected'
        },
        // expandNode: function() {
        //   this.fire('_edge.expand', this.node);
        // },
        // _getTemplateIndex: function(graphHierarchy) {
        //   return graphHierarchy.getTemplateIndex();
        // },
        // _edgeInfoSelected: function (event) {
        //   console.log(event);
        // },
        _getEdge: function (edgeName, graphHierarchy) {
          // return graphHierarchy.node(edgeName);
          console.log(edgeName,' edgeName');
          return edgeName;
        },
        _toggleExpanded: function () {
          this._expanded = !this._expanded;
        },
        _getToggleIcon: function (expanded) {
          return expanded ? "expand-less" : "expand-more";
        },
        _resizeList: function (selector) {
          var list = document.querySelector(selector);
          if (list) {
            list.fire('iron-resize');
          }
        },
        _getPrintableHTMLEdgeName: function (edgeName) {
          // Insert an optional line break before each slash so that
          // long node names wrap cleanly at path boundaries.
          return (edgeName || '').replace(/\//g, '<wbr>/');
        },
        _resetState: function () {
          // this.set("_groupButtonText",
          //   tf.graph.scene.node.getGroupSettingLabel(this._edge));

          if (this._edge) {
            Polymer.dom(this.$.edgetitle).innerHTML =
              this._getPrintableHTMLEdgeName(this._edge);
          }
        },
        // _getHeads: function(edge, hierarchy) {
        //   this.async(this._resizeList.bind(this, "#inputsList"));
        //   if (!edge) {
        //     return {regular: [], control: []}
        //   }
        //   return this._convertEdgeListToEdgeInfoList(
        //     hierarchy.getSuccessors(node.name), false, node.isGroupNode);
        // },
        // _getTails: function(edge, hierarchy) {
        //   this.async(this._resizeList.bind(this, "#outputsList"));
        //   if (!edge) {
        //     return {regular: [], control: []}
        //   }
        //   return this._convertEdgeListToEdgeInfoList(
        //     hierarchy.getPredecessors(node.name), true, node.isGroupNode);
        // },
        // _convertEdgeListToEdgeInfoList: function(list, isPredecessor, isGroupNode) {

        //   /**
        //    * Unpacks the metaedge into a list of base edge information
        //    * that can be rendered.
        //    */
        //   var unpackMetaedge = function(metaedge) {
        //     return _.map(metaedge.baseEdgeList, function(baseEdge) {
        //       var name = isPredecessor ? baseEdge.v : baseEdge.w;
        //       return {
        //         name: name,
        //         node: this._getNode(name, this.graphHierarchy),
        //         edgeLabel: tf.graph.scene.edge.getLabelForBaseEdge(baseEdge,
        //             this.renderHierarchy),
        //         renderInfo: this._getRenderInfo(name, this.renderHierarchy)
        //       };
        //     }, this);
        //   }.bind(this);

        //   /**
        //    * Converts a list of metaedges to a list of edge information
        //    * that can be rendered.
        //    */
        //   var toEdgeInfoList = function(edges) {
        //     var edgeInfoList = [];
        //     _.each(edges, function(metaedge) {
        //       var name = isPredecessor ? metaedge.v : metaedge.w;
        //       // Enumerate all the base edges if the node is an OpNode, or the
        //       // metaedge has only 1 edge in it.
        //       if (!isGroupNode || metaedge.baseEdgeList.length == 1) {
        //         edgeInfoList = edgeInfoList.concat(unpackMetaedge(metaedge));
        //       } else {
        //         edgeInfoList.push({
        //           name: name,
        //           node: this._getNode(name, this.graphHierarchy),
        //           edgeLabel: tf.graph.scene.edge.getLabelForEdge(metaedge,
        //               this.renderHierarchy),
        //           renderInfo: this._getRenderInfo(name, this.renderHierarchy)
        //         });
        //       }
        //     }, this);
        //     return edgeInfoList;
        //   }.bind(this);

        //   return {
        //     regular: toEdgeInfoList(list.regular),
        //     control: toEdgeInfoList(list.control)
        //   };
        // }
      });
    })();
  </script>
</dom-module>